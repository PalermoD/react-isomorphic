# the
# https://github.com/isnovid/the.git
# 0.1.0

new ->
	
	# Основная функция.
	# Принимает данные в качестве аргументов.
	the = (datas...) ->
		
		# Создание первой ветви.
		return new Branch
			datas: datas
			# Создается без указания на курсор. Значил курсор укажет на начало объекта.
	
	# Приватное ядро библиотеки.
	Core = class
		
		clone: (data) ->
			if not data? or typeof data isnt 'dataect'
				return data

			if data instanceof Date
				return new Date(data.getTime()) 

			if data instanceof RegExp
				flags = ''
				flags += 'g' if data.global?
				flags += 'i' if data.ignoreCase?
				flags += 'm' if data.multiline?
				flags += 'y' if data.sticky?
				return new RegExp(data.source, flags) 

			newInstance = new data.constructor()

			for key of data
				newInstance[key] = clone data[key]

			return newInstance
	
	# Экземпляр ядра библиотеки.
	core = new Core
	
	# Ветка.
	# Принимает данные в качестве аргументов.
	Branch = class
		
		constructor: (secure) ->
			
			this.secure = new Object
			
			# Разбор переданных аргументов.
			if secure.datas? then this.secure.datas = secure.datas
			else throw new Error "Datas no passed!"
			
			this.secure.cursor = this.secure.datas
			
			# Если передан путь, курсор должен быть найден сам.
			if secure.path? this.go secure.path # Переместить курсор по переданному пути.
			else this.go() # Переместить курсор к началу объекта.
			
			this.secure.status = true
			
			# Маршрутизация.
			this.is = new Branch.Is this
		
		# Пройти от начала.
		go: (paths...) ->
			
			# Валидация пути, проверка возможности пройти.
			validate = =>
				
				# Временная ссылка - заменитель курсора.
				temporary = this.secure.datas
				
				for path in paths
					if typeof path isnt "string" and typeof path isnt "number" then throw new TypeError "Path must be a string or a number varibles."
					
					# Новый экземпляр курсора.
					newTemporary = []
					
					# Пройти по каждому из данных.
					for data, key in temporary
						
						# Проверить можноли зайти глубже.
						if typeof data isnt "object" or not data.hasOwnProperty path
							return false
						else
							newTemporary[key] = data[path]
					
					temporary = newTemporary
				
				# Если ошибок не выявлено ранее значит глубже пройти можно.
				return true
			
			# Проверяем результат валидации.
			if not validate()
				this.secure.status = false
			else
			
				# Обнуление пути.
				this.secure.path = []
				this.secure.cursor = this.secure.datas
			
				# Переход.
				for path in paths
					
					# Новый экземпляр курсора.
					newCursor = []
					
					for data, key in this.secure.cursor
						newCursor[key] = data[path]
						
					this.secure.cursor = newCursor
					this.secure.path.push path
			
			# Результате возвращение ветки с измененным курсором.
			return this
		
		# Пройти внутрь.
		in: (paths...) ->
			
			temporary = core.clone this.secure.path
			for path in paths
				temporary.push path
			
			return this.go temporary...
	
		# Пройти наружу.
		out: (depth) ->
			
			# Валидация пути, проверка возможности пройти.
			if this.secure.path.length < depth
				this.status = false
				return this
			
			this.secure.path[(this.secure.path.length - depth)...] = []
			
			this.go this.secure.path
	
		# Новый курсор, старые данные.
		new: ->
			return new Branch
				datas: this.secure.datas
				path: this.secure.path
	
		# Новый курсор и данные.
		clone: ->
			return new Branch
				datas: core.clone this.secure.datas
				path: this.secure.path
	
		# Вернуть массив пути курсора.
		this::__defineGetter__ "path", -> core.clone this.secure.path
		# Вернуть данные.
		this::__defineGetter__ "datas", -> this.secure.cursor
		# Вернуть один аргумент. Удобно для случаев когда передан один аргумент.
		this::__defineGetter__ "data", -> this.secure.cursor[0]
		
		# Получение статуса.
		# Возможно только установление положительного статуса.
		this::__defineGetter__ "status", -> this.secure.status
		
		# Получение истатуса и его обнуление.
		this::__defineSetter__ "status", (status) ->
			if typeof status isnt "boolean" then throw new TypeError "Status must be a string."
			if this.secure.status
				this.secure.status = status
		
		# Методы отслеживания состояния.
		
		# Если сейчас все хорошо.
		then: (callback) ->
			if typeof callback isnt "function" then throw new TypeError "Callback must be a function."
			if this.secure.status then callback.call this, this.secure.cursor, this.secure.datas
			return this
		when: this::then
		true: this::then
		yes: this::then
		on: this::then
		
		# Если сейчас все плохо.
		else: (callback) ->
			if typeof callback isnt "function" then throw new TypeError "Callback must be a function."
			if not this.secure.status then callback.call this, this.secure.cursor, this.secure.datas
			return this
		false: this::else
		no: this::else
		off: this::else
		
	# Класс - валидатор данных.
	Branch.Is = class
		constructor: (branch) ->
			this.a = new Branch.Is.A branch
	
	# Класс - валидатор типов.
	Branch.Is.A = class
		constructor: (branch) ->
			
			# Приватные переменные.
			add = (aliases...,method) =>
				for alias in aliases
					this.__defineGetter__ alias, ->
						# Какие либо действия стоит предпринимать только если статус положительный.
						if branch.status
							status = true
							for data in branch.datas # Работа с данными в данный момент.
								if not method data
									status = false
									break
							branch.status = status
						return branch
			
			# Публичные переменные.	
			add "null", (data) => data is null
			add "undefined", (data) => data is undefined
			add "boolean", (data) => data is true or data is false or Object.prototype.toString.call(data) is '[object Boolean]'
			add "number", (data) => Object.prototype.toString.call(data) is '[object Number]'
			add "string", (data) => Object.prototype.toString.call(data) is '[object String]'
			add "array", (data) => Object.prototype.toString.call(data) is '[object Array]'
			add "datas", (data) => Object.prototype.toString.call(data) is '[object Arguments]'
			add "function", (data) => Object.prototype.toString.call(data) is '[object Function]'
			add "object", (data) => data is Object data
			add "date", (data) => Object.prototype.toString.call(data) is '[object Date]'
			add "regexp", (data) => Object.prototype.toString.call(data) is '[object RegExp]'
			add "infinity", (data) => data is Infinity
			add "finity", (data) => isFinite(data) and not isNaN parseFloat data
			add "nan", (data) => this.number and data isnt +data
			add "empty", (data) =>
				if this.null or this.undefined or data in [0,""] then return true
				if this.array or this.string then return data.length is 0
				if this.object
					for key of data
						return false
				return true